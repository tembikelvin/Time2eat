class PWAManager { constructor() { this.deferredPrompt = null; this.isInstalled = false; this.isOnline = navigator.onLine; this.swRegistration = null; this.init(); } async init() { this.checkInstallation(); this.setupEventListeners(); await this.registerServiceWorker(); this.setupPushNotifications(); this.initOfflineSupport(); } checkInstallation() { this.isInstalled = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone || document.referrer.includes('android-app: if (this.isInstalled) { this.hideInstallPrompts(); } } setupEventListeners() { window.addEventListener('beforeinstallprompt', (e) => { console.log('[PWA] Install prompt available'); e.preventDefault(); this.deferredPrompt = e; this.showInstallButton(); }); window.addEventListener('appinstalled', () => { console.log('[PWA] App installed successfully'); this.isInstalled = true; this.hideInstallPrompts(); this.showNotification('Time2Eat installed successfully!', 'success'); }); window.addEventListener('online', () => { this.isOnline = true; this.handleOnline(); }); window.addEventListener('offline', () => { this.isOnline = false; this.handleOffline(); }); document.addEventListener('swUpdated', () => { this.showUpdateAvailable(); }); } async registerServiceWorker() { if ('serviceWorker' in navigator) { try { this.swRegistration = await navigator.serviceWorker.register('/sw.js', { scope: '/' }); console.log('[PWA] Service worker registered:', this.swRegistration); this.swRegistration.addEventListener('updatefound', () => { const newWorker = this.swRegistration.installing; newWorker.addEventListener('statechange', () => { if (newWorker.state === 'installed' && navigator.serviceWorker.controller) { document.dispatchEvent(new CustomEvent('swUpdated')); } }); }); navigator.serviceWorker.addEventListener('message', (event) => { this.handleServiceWorkerMessage(event.data); }); } catch (error) { console.error('[PWA] Service worker registration failed:', error); } } } showInstallButton() { const installButtons = document.querySelectorAll('.pwa-install-button'); installButtons.forEach(button => { button.style.display = 'block'; button.addEventListener('click', () => this.installApp()); }); } hideInstallPrompts() { const installButtons = document.querySelectorAll('.pwa-install-button'); const installSections = document.querySelectorAll('.pwa-install-section'); installButtons.forEach(button => button.style.display = 'none'); installSections.forEach(section => section.style.display = 'none'); } async installApp() { if (!this.deferredPrompt) { this.showNotification('Installation not available', 'error'); return; } try { this.deferredPrompt.prompt(); const { outcome } = await this.deferredPrompt.userChoice; if (outcome === 'accepted') { console.log('[PWA] User accepted install prompt'); this.trackEvent('pwa_install_accepted'); } else { console.log('[PWA] User dismissed install prompt'); this.trackEvent('pwa_install_dismissed'); } this.deferredPrompt = null; } catch (error) { console.error('[PWA] Install failed:', error); this.showNotification('Installation failed', 'error'); } } async setupPushNotifications() { if (!('Notification' in window) || !('serviceWorker' in navigator)) { console.log('[PWA] Push notifications not supported'); return; } if (Notification.permission === 'granted') { await this.subscribeToPush(); } else if (Notification.permission !== 'denied') { this.showNotificationPrompt(); } } showNotificationPrompt() { const notificationPrompts = document.querySelectorAll('.notification-prompt'); notificationPrompts.forEach(prompt => { prompt.style.display = 'block'; const enableButton = prompt.querySelector('.enable-notifications'); if (enableButton) { enableButton.addEventListener('click', () => this.requestNotificationPermission()); } }); } async requestNotificationPermission() { try { const permission = await Notification.requestPermission(); if (permission === 'granted') { console.log('[PWA] Notification permission granted'); await this.subscribeToPush(); this.hideNotificationPrompts(); this.showNotification('Notifications enabled!', 'success'); this.trackEvent('notifications_enabled'); } else { console.log('[PWA] Notification permission denied'); this.trackEvent('notifications_denied'); } } catch (error) { console.error('[PWA] Notification permission request failed:', error); } } async subscribeToPush() { if (!this.swRegistration) { console.log('[PWA] Service worker not registered'); return; } try { const subscription = await this.swRegistration.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: this.urlBase64ToUint8Array(this.getVapidPublicKey()) }); console.log('[PWA] Push subscription created:', subscription); await this.sendSubscriptionToServer(subscription); } catch (error) { console.error('[PWA] Push subscription failed:', error); } } hideNotificationPrompts() { const notificationPrompts = document.querySelectorAll('.notification-prompt'); notificationPrompts.forEach(prompt => prompt.style.display = 'none'); } handleOnline() { console.log('[PWA] Back online'); this.showNotification('Connection restored', 'success'); this.syncOfflineData(); this.updateOnlineStatus(true); } handleOffline() { console.log('[PWA] Gone offline'); this.showNotification('You are now offline', 'warning'); this.updateOnlineStatus(false); } updateOnlineStatus(isOnline) { const statusIndicators = document.querySelectorAll('.connection-status'); statusIndicators.forEach(indicator => { if (isOnline) { indicator.classList.remove('offline'); indicator.classList.add('online'); indicator.textContent = 'Online'; } else { indicator.classList.remove('online'); indicator.classList.add('offline'); indicator.textContent = 'Offline'; } }); } initOfflineSupport() { this.cacheEssentialData(); this.setupOfflineForms(); this.setupBackgroundSync(); } async cacheEssentialData() { if (!this.swRegistration) return; try { const restaurants = await this.fetchWithFallback('/api/restaurants'); if (restaurants) { localStorage.setItem('cached_restaurants', JSON.stringify(restaurants)); } const favorites = await this.fetchWithFallback('/api/user/favorites'); if (favorites) { localStorage.setItem('cached_favorites', JSON.stringify(favorites)); } } catch (error) { console.error('[PWA] Failed to cache essential data:', error); } } setupOfflineForms() { const forms = document.querySelectorAll('form[data-offline-sync]'); forms.forEach(form => { form.addEventListener('submit', (e) => { if (!this.isOnline) { e.preventDefault(); this.handleOfflineFormSubmission(form); } }); }); } handleOfflineFormSubmission(form) { const formData = new FormData(form); const data = Object.fromEntries(formData.entries()); const offlineData = JSON.parse(localStorage.getItem('offline_forms') || '[]'); offlineData.push({ id: Date.now(), action: form.action, method: form.method, data: data, timestamp: new Date().toISOString() }); localStorage.setItem('offline_forms', JSON.stringify(offlineData)); this.showNotification('Form saved. Will sync when online.', 'info'); if (this.swRegistration && 'sync' in this.swRegistration) { this.swRegistration.sync.register('background-sync-forms'); } } setupBackgroundSync() { if (!this.swRegistration || !('sync' in this.swRegistration)) { console.log('[PWA] Background sync not supported'); return; } this.swRegistration.sync.register('background-sync-cart'); this.swRegistration.sync.register('background-sync-orders'); } async syncOfflineData() { try { const offlineForms = JSON.parse(localStorage.getItem('offline_forms') || '[]'); for (const formData of offlineForms) { try { const response = await fetch(formData.action, { method: formData.method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(formData.data) }); if (response.ok) { console.log('[PWA] Offline form synced:', formData.id); } } catch (error) { console.error('[PWA] Failed to sync form:', error); } } localStorage.removeItem('offline_forms'); } catch (error) { console.error('[PWA] Offline data sync failed:', error); } } showUpdateAvailable() { const updateBanner = document.createElement('div'); updateBanner.className = 'pwa-update-banner'; updateBanner.innerHTML = ` <div class="tw-bg-blue-500 tw-text-white tw-p-4 tw-fixed tw-top-0 tw-left-0 tw-right-0 tw-z-50"> <div class="tw-flex tw-items-center tw-justify-between"> <span>A new version is available!</span> <button onclick="pwaManager.updateApp()" class="tw-bg-white tw-text-blue-500 tw-px-4 tw-py-2 tw-rounded tw-font-medium"> Update Now </button> </div> </div> `; document.body.appendChild(updateBanner); } updateApp() { if (this.swRegistration && this.swRegistration.waiting) { this.swRegistration.waiting.postMessage({ type: 'SKIP_WAITING' }); window.location.reload(); } } handleServiceWorkerMessage(data) { switch (data.type) { case 'CACHE_UPDATED': console.log('[PWA] Cache updated'); break; case 'OFFLINE_FALLBACK': this.showNotification('Loading offline content', 'info'); break; default: console.log('[PWA] Service worker message:', data); } } async fetchWithFallback(url) { try { const response = await fetch(url); return response.ok ? await response.json() : null; } catch (error) { console.error('[PWA] Fetch failed:', url, error); return null; } } urlBase64ToUint8Array(base64String) { const padding = '='.repeat((4 - base64String.length % 4) % 4); const base64 = (base64String + padding) .replace(/-/g, '+') .replace(/_/g, '/'); const rawData = window.atob(base64); const outputArray = new Uint8Array(rawData.length); for (let i = 0; i < rawData.length; ++i) { outputArray[i] = rawData.charCodeAt(i); } return outputArray; } getVapidPublicKey() { return 'BEl62iUYgUivxIkv69yViEuiBIa40HI80NqIUHI80NqIUHI80NqIUHI80NqIUHI80NqIUHI80NqIUHI80NqIUHI80NqI'; } async sendSubscriptionToServer(subscription) { try { const response = await fetch('/api/push/subscribe', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(subscription) }); if (response.ok) { console.log('[PWA] Subscription sent to server'); } } catch (error) { console.error('[PWA] Failed to send subscription to server:', error); } } showNotification(message, type = 'info') { const notification = document.createElement('div'); notification.className = `pwa-notification tw-fixed tw-top-4 tw-right-4 tw-p-4 tw-rounded-lg tw-shadow-lg tw-z-50 ${ type === 'success' ? 'tw-bg-green-500' : type === 'error' ? 'tw-bg-red-500' : type === 'warning' ? 'tw-bg-yellow-500' : 'tw-bg-blue-500' } tw-text-white`; notification.textContent = message; document.body.appendChild(notification); setTimeout(() => { notification.remove(); }, 3000); } trackEvent(eventName, data = {}) { if (typeof gtag !== 'undefined') { gtag('event', eventName, data); } console.log('[PWA] Event tracked:', eventName, data); } } let pwaManager; document.addEventListener('DOMContentLoaded', () => { pwaManager = new PWAManager(); }); window.pwaManager = pwaManager;